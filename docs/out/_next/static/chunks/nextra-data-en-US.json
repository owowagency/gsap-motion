{"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/getting-started/basic-use":{"title":"Basic usage","data":{"importing-modules#Importing modules":"To start using our animation library, you first need to import the necessary utilities and presets. The library is designed to be modular, so you only need to import the parts you need for your project.\nimport { Ease } from \"@owowagency/gsap-motion\";\nconst halfWay = Ease.inCubic(0.5);","your-first-motion#Your first motion":"Why not start with a basic example. We will create a basic tween that infinitely animates the <body>'s background color from and to blue.\nimport { createMotion } from \"@owowagency/gsap-motion\";\nimport gsap from \"gsap\";\ncreateMotion(() => {\n  gsap.to(\"body\", {\n    background: \"blue\",\n    yoyo: true,\n    repeat: -1,\n  });\n});\nSo what is so special about createMotion() in this case? After all, we can achieve the same with simply calling gsap.to(\"body\", { ... }).Indeed, we could achieve the same effect by simply calling gsap.to(\"body\", { ... }). However, real-world scenarios often require us to handle more complex situations. These include responding to window or element resizes, applying animations conditionally (for instance, based on media queries), and ensuring proper cleanup after the animations are done.","a-proper-example#A proper example":"In the following example, we'll demonstrate a more complex use case. It involves multiple tweens that are conditionally applied to screens wider than 800px, using a media query. The animation is integrated within a Vue component, necessitating tween cleanup upon component unmounting. Additionally, we'll need to reinitialize the tweens when our target element resizes, allowing for necessary recalculations.\n<template>\n  <div id=\"container\">\n    <div id=\"bouncy-ball\" class=\"bouncy-ball\" />\n  </div>\n</template>\n<script>\nimport { createMotion } from \"@owowagency/gsap-motion\";\nimport gsap from \"gsap\";\nimport { ref, onMounted, onBeforeUnmount } from \"vue\";\nlet destroyMotion;\nonMounted(() => {\n  destroyMotion = createMotion(\n    () => {\n      const context = gsap.matchMedia();\n      const bounceRange = window.innerHeight * 0.5;\n      const slideInRange = window.innerWidth * 0.1;\n      context.add(\"(min-width: 800px)\", () => {\n        gsap.fromTo(\n          \"#container\",\n          {\n            x: slideInRange,\n          },\n          {\n            x: 0,\n            duration: 2,\n            ease: \"power2.out\",\n          }\n        );\n        gsap.to(\"#bouncy-ball\", {\n          x: bounceRange,\n          ease: \"power2.out\",\n          duration: 1,\n          yoyo: true,\n          repeat: -1,\n        });\n      });\n      return () => {\n        context.kill(true);\n      };\n    },\n    { observeWindowResize: true }\n  );\n});\nonBeforeUnmount(() => {\n  destroyMotion();\n});\n</script>"}},"/getting-started/installation":{"title":"Installation","data":{"":"Our library depends on GSAP and RxJS under the hood. So install these along with our library.\nnpm install @owowagency/gsap-motion gsap rxjs\nyarn add @owowagency/gsap-motion gsap rxjs\npnpm install @owowagency/gsap-motion gsap rxjs","why-gsap#Why GSAP?":"In our library, GSAP is used as a foundation for utilities and drop-in preset animation.GSAP, or GreenSock Animation Platform, is a robust and highly flexible library for JavaScript animations. It's considered the best in the JavaScript ecosystem due to its performance, compatibility, and extensive features. GSAP provides smooth animations by leveraging hardware acceleration and offers a simple API for complex animations. It supports a wide range of targets like CSS properties, SVG, React, canvas libraries, and more. With GSAP, developers can create animations that are highly interactive, precise, and compatible across various browsers and devices.","why-rxjs#Why RxJS?":"In our library, RxJS is used for internal state management and handling various browser events and other observer patterns.RxJS, or Reactive Extensions for JavaScript, is a powerful library that simplifies handling asynchronous or callback-based code using Observables. It's a staple in the JavaScript ecosystem, widely used in various frameworks like Angular, due to its ability to manage complex asynchronous operations efficiently. With RxJS, developers can control multiple events, merge, transform, and even cancel them, making code more readable and maintainable."}},"/getting-started/presets":{"title":"Presets","data":{"":"Presets are pre-configured animations that you can easily drop into your projects to create beautiful effects with minimal effort. They are designed to be flexible and customizable, allowing you to adjust parameters to suit your specific needs. Our library currently features the following presets:","presets#Presets":"Diorama: The createDiorama() preset provides a unique 3D scrolling effect, creating a sense of depth and immersion. It's perfect for creating parallax scrolling websites or adding a touch of interactivity to your web pages.\nMarquee: The createMarquee() preset allows you to create classic marquee animations. This preset is great for creating scrolling text or image sliders.\nParallax: The createParallax() preset enables you to create parallax scrolling effects. This effect can add a sense of depth to your web pages, making them more engaging and visually interesting.\nText Clip Reveal: The createTextClipReveal() preset is designed for revealing text in a creative way. It's perfect for titles, headers, or any text that you want to stand out.","motion#Motion":"Each preset implements the createMotion() utility, which comes with a destroy function, allowing you to manually stop and clean up the effect when it's no longer needed. This ensures optimal performance and resource management in your projects."}},"/getting-started/utilities":{"title":"Utilities","data":{"":"Utilities are a set of helper functions designed to simplify common tasks when creating animations. They provide a low-level API that can be used to build custom animations or to extend the functionality of the existing presets. Our library currently features four powerful utilities:","summary#Summary":"Motion: The createMotion() utility is the core of our library. It provides a flexible API for creating custom motion effects. This utility is used in all presets, but can also be used directly to create custom animations.\nEasing: The Ease utility provides a collection of easing functions that can be used to control the rate of change of an animation. These functions can be used to create more natural and dynamic animations by varying the speed over the duration of the animation.\nMouse Position: The mousePosition() utility provides a simple way to interact with the mouse position. It provides normalized positions (between 0 and 1) for the client (window), page, and screen. This can be useful for creating interactive animations that respond to the user's mouse movements.\nPhysics-Based Motion: The physicsBasedMotion() utility provides a way to create animations that simulate the motion of physical objects. It uses parameters such as speed, damping, and response to create realistic motion effects.\nEach utility is designed to be easy to use and flexible, allowing you to create complex animations with minimal effort."}},"/":{"title":"Introduction","data":{"":"Welcome to @owowagency/gsap-motion! A web animation library, based on GSAP.Motion and animations are amazing! But they can be complex to manage.We have to deal with a myriad of different devices, changing layouts, resource management -- all while keep things running buttery smooth.This library is a comprehensive toolkit for creating and managing animations with ease. It features a variety of animation utilities, as well as preset drop-in animation functions, allowing you to effortlessly create a wide range of effects.The library is framework agnostic, meaning it can be seamlessly integrated into any project that already includes GSAP."}}}